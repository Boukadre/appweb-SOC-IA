"""
VirusTotal API v3 Client
Documentation: https://developers.virustotal.com/reference/overview
"""
import httpx
import hashlib
from typing import Optional, Dict, Any
from app.core.config import settings


class VirusTotalClient:
    """Client pour l'API VirusTotal v3"""
    
    def __init__(self):
        self.base_url = settings.VIRUSTOTAL_BASE_URL
        self.api_key = settings.VIRUSTOTAL_API_KEY
        self.timeout = settings.EXTERNAL_API_TIMEOUT
    
    def _get_headers(self) -> Dict[str, str]:
        """Retourne les headers pour les requêtes API"""
        return {
            "x-apikey": self.api_key,
            "Accept": "application/json"
        }
    
    async def get_file_report(self, file_hash: str) -> Optional[Dict[str, Any]]:
        """
        Récupère le rapport d'analyse d'un fichier via son hash
        
        Args:
            file_hash: MD5, SHA1 ou SHA256 du fichier
        
        Returns:
            Dict contenant le rapport d'analyse ou None si erreur
        """
        if not self.api_key:
            print("⚠️ VirusTotal API Key non configurée")
            return None
        
        try:
            async with httpx.AsyncClient(timeout=self.timeout) as client:
                response = await client.get(
                    f"{self.base_url}/files/{file_hash}",
                    headers=self._get_headers()
                )
                
                if response.status_code == 404:
                    print(f"ℹ️ Fichier non trouvé dans VirusTotal: {file_hash}")
                    return {
                        "found": False,
                        "message": "File not found in VirusTotal database"
                    }
                
                response.raise_for_status()
                data = response.json()
                
                if "data" in data:
                    return self._parse_file_report(data["data"])
                
                return None
                
        except httpx.HTTPStatusError as e:
            print(f"❌ Erreur HTTP VirusTotal: {e.response.status_code}")
            if e.response.status_code == 401:
                print("   Clé API invalide")
            elif e.response.status_code == 429:
                print("   Rate limit dépassé (4 requests/minute pour free tier)")
            return None
        except httpx.TimeoutException:
            print(f"⏱️ Timeout lors de la requête VirusTotal")
            return None
        except Exception as e:
            print(f"❌ Erreur VirusTotal: {str(e)}")
            return None
    
    async def scan_url(self, url: str) -> Optional[str]:
        """
        Soumet une URL pour analyse
        
        Args:
            url: URL à analyser
        
        Returns:
            ID de l'analyse ou None si erreur
        """
        if not self.api_key:
            return None
        
        try:
            async with httpx.AsyncClient(timeout=self.timeout) as client:
                response = await client.post(
                    f"{self.base_url}/urls",
                    headers=self._get_headers(),
                    data={"url": url}
                )
                
                response.raise_for_status()
                data = response.json()
                
                if "data" in data and "id" in data["data"]:
                    return data["data"]["id"]
                
                return None
                
        except Exception as e:
            print(f"❌ Erreur lors du scan URL VirusTotal: {str(e)}")
            return None
    
    async def get_url_report(self, url_id: str) -> Optional[Dict[str, Any]]:
        """
        Récupère le rapport d'analyse d'une URL
        
        Args:
            url_id: ID de l'analyse URL (ou hash base64 de l'URL)
        
        Returns:
            Dict contenant le rapport d'analyse
        """
        if not self.api_key:
            return None
        
        try:
            async with httpx.AsyncClient(timeout=self.timeout) as client:
                response = await client.get(
                    f"{self.base_url}/urls/{url_id}",
                    headers=self._get_headers()
                )
                
                response.raise_for_status()
                data = response.json()
                
                if "data" in data:
                    return self._parse_url_report(data["data"])
                
                return None
                
        except Exception as e:
            print(f"❌ Erreur lors de la récupération du rapport URL: {str(e)}")
            return None
    
    def _parse_file_report(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Parse et simplifie le rapport de fichier"""
        attributes = data.get("attributes", {})
        stats = attributes.get("last_analysis_stats", {})
        
        return {
            "found": True,
            "file_name": attributes.get("meaningful_name", "Unknown"),
            "file_type": attributes.get("type_description", "Unknown"),
            "file_size": attributes.get("size", 0),
            "md5": attributes.get("md5", ""),
            "sha256": attributes.get("sha256", ""),
            "stats": stats,
            "malicious": stats.get("malicious", 0),
            "suspicious": stats.get("suspicious", 0),
            "harmless": stats.get("harmless", 0),
            "undetected": stats.get("undetected", 0),
            "total_engines": sum(stats.values()),
            "detection_names": self._extract_detection_names(attributes.get("last_analysis_results", {})),
            "first_seen": attributes.get("first_submission_date", 0),
            "last_seen": attributes.get("last_analysis_date", 0)
        }
    
    def _parse_url_report(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Parse et simplifie le rapport d'URL"""
        attributes = data.get("attributes", {})
        stats = attributes.get("last_analysis_stats", {})
        
        return {
            "found": True,
            "url": attributes.get("url", ""),
            "stats": stats,
            "malicious": stats.get("malicious", 0),
            "suspicious": stats.get("suspicious", 0),
            "harmless": stats.get("harmless", 0),
            "undetected": stats.get("undetected", 0),
            "total_engines": sum(stats.values()),
            "detection_names": self._extract_detection_names(attributes.get("last_analysis_results", {}))
        }
    
    def _extract_detection_names(self, results: Dict[str, Any]) -> list[str]:
        """Extrait les noms de détection des moteurs qui ont trouvé une menace"""
        detections = []
        
        for engine, result in results.items():
            if result.get("category") in ["malicious", "suspicious"]:
                detection = result.get("result", "")
                if detection and detection != "None":
                    detections.append(f"{engine}: {detection}")
        
        return detections[:10]  # Limiter à 10 détections


# Instance singleton
virustotal_client = VirusTotalClient()


